<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤¾åŒºåœ°å›¾ä¿¡æ¯æŸ¥è¯¢</title>
    <!-- html2canvasåº“ç”¨äºæˆªå›¾åŠŸèƒ½ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Microsoft YaHei', sans-serif;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
            height: calc(100vh - 120px);
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                height: auto;
                gap: 15px;
            }

            .info-panel {
                width: 100%;
                order: -1;
            }

            .map-container {
                min-height: 400px;
            }

            body {
                padding: 10px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 15px;
            }

            .map-controls {
                flex-wrap: wrap;
                gap: 8px;
            }

            .zoom-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
        }

        .map-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            min-height: 600px;
        }

        .map-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .zoom-btn {
            padding: 8px 12px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s, transform 0.2s;
        }

        .zoom-btn:hover {
            background: #1976D2;
            transform: translateY(-1px);
        }

        .zoom-btn:active {
            transform: translateY(0);
        }

        .zoom-btn:disabled {
            background: #cccccc !important;
            cursor: not-allowed;
            transform: none;
        }

        .zoom-btn:disabled:hover {
            background: #cccccc !important;
            transform: none;
        }

        .zoom-level {
            color: #666;
            font-size: 14px;
            margin-left: 10px;
        }

        #map-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            position: relative;
            background: #fafafa;
        }

        #map-svg {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        /* åœ°å›¾ä¸Šçš„ä¿¡æ¯æ˜¾ç¤ºæ ·å¼ */
        .map-info-overlay {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #9C27B0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            font-family: 'Microsoft YaHei', sans-serif;
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.3);
            z-index: 1000;
            max-width: 180px;
            min-width: 140px;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }

        .map-info-overlay:hover {
            box-shadow: 0 6px 16px rgba(156, 39, 176, 0.4);
            transform: translateY(-2px);
        }

        .map-info-overlay.dragging {
            box-shadow: 0 8px 20px rgba(156, 39, 176, 0.5);
            transform: rotate(2deg) scale(1.05);
        }

        .map-info-title {
            font-weight: bold;
            font-size: 13px;
            color: #9C27B0;
            margin-bottom: 4px;
            border-bottom: 1px solid #E1BEE7;
            padding-bottom: 2px;
            cursor: move;
        }

        .map-info-item {
            margin: 2px 0;
            font-size: 11px;
            color: #333;
        }

        .map-info-label {
            color: #666;
            font-weight: normal;
        }

        .map-info-value {
            color: #333;
            font-weight: bold;
        }

        .map-info-total {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid #E1BEE7;
            font-weight: bold;
            color: #9C27B0;
            font-size: 12px;
        }

        /* å¼•çº¿æ ·å¼ */
        .map-leader-line {
            stroke: #2196F3;
            stroke-width: 2;
            fill: none;
            pointer-events: none;
            stroke-dasharray: 5,3;
            opacity: 0.8;
        }

        .map-leader-dot {
            fill: #2196F3;
            stroke: white;
            stroke-width: 1.5;
            pointer-events: none;
        }

        .info-panel {
            width: 300px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .community-area {
            transition: fill 0.3s ease, stroke 0.3s ease;
        }

        .community-area:hover {
            fill: #FF9800 !important;
            opacity: 0.8;
            stroke: #F57C00;
            stroke-width: 2px;
        }

        .community-area.selected {
            fill: #4CAF50 !important;
            opacity: 0.9;
            stroke: #2E7D32;
            stroke-width: 2px;
        }

        .info-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #9C27B0;
            padding-bottom: 10px;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .info-label {
            font-weight: bold;
            color: #555;
        }

        .info-value {
            color: #333;
            margin-left: 10px;
        }

        .no-data {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .loading {
            color: #666;
            text-align: center;
            padding: 20px;
        }

        .error {
            color: #f44336;
            text-align: center;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }

        .file-upload-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }

        .file-upload-area {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            background: #2196F3;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
            display: inline-block;
        }

        .file-input-label:hover {
            background: #1976D2;
        }

        .file-status {
            color: #666;
            font-size: 14px;
        }

        .file-status.success {
            color: #4CAF50;
        }

        .file-status.error {
            color: #f44336;
        }

        .upload-progress {
            color: #FF9800;
        }

        .chart-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #ddd;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .chart-controls label {
            font-size: 14px;
            color: #666;
            font-weight: bold;
        }

        .chart-controls select {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .chart-btn {
            padding: 8px 16px;
            background: #9C27B0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .chart-btn:hover {
            background: #7B1FA2;
        }

        .chart-btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .chart-status {
            font-size: 12px;
            color: #666;
        }

        .column-checkbox {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .column-checkbox:hover {
            background: #e9ecef;
        }

        .column-checkbox.selected {
            background: #667EEA;
            color: white;
            border-color: #5A67D8;
        }

        .column-checkbox input[type="checkbox"] {
            margin: 0;
            transform: scale(0.8);
        }

        /* å›¾ä¾‹æ ·å¼ */
        .chart-legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1001;
            max-width: 250px;
            font-family: 'Microsoft YaHei', sans-serif;
            display: none;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .chart-legend:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .chart-legend.dragging {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.02);
        }

        .chart-legend.visible {
            display: block;
        }

        .legend-title {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .legend-label {
            color: #555;
            flex-grow: 1;
        }
    </style>
</head>
<body>
    <h1>ç¤¾åŒºåœ°å›¾ä¿¡æ¯æŸ¥è¯¢ç³»ç»Ÿ</h1>

    <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
    <div class="file-upload-section">
        <div class="file-upload-area">
            <div class="file-input-wrapper">
                <input type="file" id="excel-file-input" class="file-input" accept=".xlsx,.xls">
                <label for="excel-file-input" class="file-input-label">ğŸ“ é€‰æ‹©Excelæ–‡ä»¶</label>
            </div>
            <div id="file-status" class="file-status">
                å½“å‰æ–‡ä»¶: <span id="current-filename">åŠ è½½ä¸­...</span>
                (<span id="community-count">-</span>ä¸ªç¤¾åŒº/æ‘)
            </div>
        </div>
    </div>

    <div class="container">
        <div class="map-container">
            <div class="map-controls">
                <button class="zoom-btn" onclick="zoomIn()">æ”¾å¤§ +</button>
                <button class="zoom-btn" onclick="zoomOut()">ç¼©å° -</button>
                <button class="zoom-btn" onclick="resetZoom()">é‡ç½®è§†å›¾</button>
                <button class="zoom-btn" onclick="fitToView()">é€‚åº”çª—å£</button>
                <span class="zoom-level">ç¼©æ”¾: <span id="zoom-percentage">100%</span></span>
                <div style="margin-left: 20px; border-left: 2px solid #ddd; padding-left: 20px;">
                    <button class="zoom-btn" onclick="selectAll()" style="background: #4CAF50;">å…¨é€‰</button>
                    <button class="zoom-btn" onclick="clearAll()" style="background: #f44336;">æ¸…ç©º</button>
                    <button class="zoom-btn" onclick="toggleAllInfoBoxes()" id="toggle-info-btn" style="background: #FF9800;">éšè—ä¿¡æ¯æ¡†</button>
                    <span class="zoom-level">å·²é€‰: <span id="selected-count">0</span>ä¸ª</span>
                </div>
            </div>

            <!-- æŸ±çŠ¶å›¾æ§åˆ¶åŒºåŸŸ -->
            <div class="chart-controls">
                <label for="chart-mode-select">å›¾è¡¨æ¨¡å¼:</label>
                <select id="chart-mode-select">
                    <option value="bar">æŸ±çŠ¶å›¾</option>
                    <option value="pie">é¥¼å›¾</option>
                </select>

                <label for="chart-column-select">æ•°æ®é€‰æ‹©:</label>
                <div id="column-checkboxes" style="display: inline-flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <!-- åŠ¨æ€ç”Ÿæˆçš„å¤é€‰æ¡†å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>

                <button id="draw-chart-btn" class="chart-btn" onclick="drawChartForSelected()" disabled>
                    ğŸ“Š ç»˜åˆ¶å›¾è¡¨
                </button>
                <button id="clear-charts-btn" class="chart-btn" onclick="clearAllCharts()" style="background: #f44336;">
                    ğŸ—‘ï¸ æ¸…é™¤å›¾è¡¨
                </button>
                <span class="chart-status" id="chart-status">è¯·å…ˆé€‰æ‹©ç¤¾åŒºå’Œæ•°æ®åˆ—</span>
            </div>
            <div id="map-container">
                <!-- SVGåœ°å›¾å°†åœ¨è¿™é‡ŒåŠ è½½ -->
            </div>
        </div>

        <div class="info-panel">
            <div class="info-title">ç¤¾åŒºç»Ÿè®¡ä¿¡æ¯</div>
            <div id="community-info">
                <div class="no-data">è¯·ç‚¹å‡»åœ°å›¾ä¸Šçš„ç¤¾åŒº/æ‘æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ï¼Œæ”¯æŒå¤šé€‰</div>
            </div>
        </div>
    </div>

    <!-- å›¾è¡¨å›¾ä¾‹ -->
    <div id="chart-legend" class="chart-legend">
        <div class="legend-title">æ•°æ®å›¾ä¾‹</div>
        <div id="legend-content">
            <!-- åŠ¨æ€ç”Ÿæˆå›¾ä¾‹é¡¹ -->
        </div>
    </div>

    <script>
        let selectedCommunities = new Set();  // å­˜å‚¨å¤šé€‰çš„ç¤¾åŒº
        let communityData = {};
        let currentZoom = 1;
        let mapSvg = null;
        let infoBoxes = new Map(); // å­˜å‚¨ä¿¡æ¯æ¡†çš„ä½ç½®ä¿¡æ¯
        let dragState = {
            isDragging: false,
            element: null,
            offsetX: 0,
            offsetY: 0,
            isLegend: false  // æ ‡è®°æ˜¯å¦æ˜¯å›¾ä¾‹æ‹–æ‹½
        };
        let linesOverlay = null; // å¼•çº¿è¦†ç›–å±‚
        let chartsOverlay = null; // æŸ±çŠ¶å›¾è¦†ç›–å±‚
        let availableColumns = []; // å¯ç”¨çš„æ•°æ®åˆ—
        let infoBoxesVisible = true; // ä¿¡æ¯æ¡†æ˜¾ç¤ºçŠ¶æ€
        let hiddenInfoBoxes = new Map(); // å­˜å‚¨éšè—çš„ä¿¡æ¯æ¡†æ•°æ®
        let selectedColumns = new Set(); // é€‰ä¸­çš„æ•°æ®åˆ—

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadSVGMap();
            loadCurrentFileInfo();
            loadCommunityData();
            setupFileUpload();
        });

        // è®¾ç½®æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
        function setupFileUpload() {
            const fileInput = document.getElementById('excel-file-input');
            fileInput.addEventListener('change', handleFileUpload);

            // æ·»åŠ å›¾è¡¨æ¨¡å¼é€‰æ‹©ç›‘å¬å™¨
            const modeSelect = document.getElementById('chart-mode-select');
            modeSelect.addEventListener('change', updateChartStatus);
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileStatus = document.getElementById('file-status');
            fileStatus.className = 'file-status upload-progress';
            fileStatus.innerHTML = 'ä¸Šä¼ ä¸­...';

            try {
                const formData = new FormData();
                formData.append('file', file);

                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    fileStatus.className = 'file-status success';
                    fileStatus.innerHTML = result.message;

                    // æ›´æ–°å½“å‰æ–‡ä»¶ä¿¡æ¯
                    document.getElementById('current-filename').textContent = result.filename;
                    document.getElementById('community-count').textContent = result.community_count;

                    // é‡æ–°åŠ è½½ç¤¾åŒºæ•°æ®
                    await loadCommunityData();

                    // æ¸…ç©ºå½“å‰é€‰æ‹©
                    clearAll();

                    console.log('æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼Œæ•°æ®å·²æ›´æ–°');
                } else {
                    throw new Error(result.error || 'ä¸Šä¼ å¤±è´¥');
                }
            } catch (error) {
                fileStatus.className = 'file-status error';
                fileStatus.innerHTML = `ä¸Šä¼ å¤±è´¥: ${error.message}`;
                console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
            }

            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡æ–°é€‰æ‹©åŒä¸€æ–‡ä»¶
            event.target.value = '';
        }

        // åŠ è½½å½“å‰æ–‡ä»¶ä¿¡æ¯
        async function loadCurrentFileInfo() {
            try {
                const response = await fetch('/api/current-file');
                const result = await response.json();

                if (response.ok) {
                    document.getElementById('current-filename').textContent = result.filename;
                    document.getElementById('community-count').textContent = result.community_count;

                    if (result.file_exists) {
                        document.getElementById('file-status').className = 'file-status success';
                    } else {
                        document.getElementById('file-status').className = 'file-status error';
                    }
                } else {
                    document.getElementById('file-status').className = 'file-status error';
                    document.getElementById('file-status').innerHTML = 'è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥';
                }
            } catch (error) {
                console.error('è·å–å½“å‰æ–‡ä»¶ä¿¡æ¯å¤±è´¥:', error);
                document.getElementById('file-status').className = 'file-status error';
                document.getElementById('file-status').innerHTML = 'è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥';
            }
        }

        // ç¼©æ”¾åŠŸèƒ½
        function zoomIn() {
            currentZoom = Math.min(currentZoom * 1.2, 5);
            applyZoom();
        }

        function zoomOut() {
            currentZoom = Math.max(currentZoom / 1.2, 0.1);
            applyZoom();
        }

        function resetZoom() {
            currentZoom = 1;
            applyZoom();
        }

        function fitToView() {
            if (mapSvg) {
                const container = document.getElementById('map-container');
                const containerRect = container.getBoundingClientRect();
                const svgRect = mapSvg.getBoundingClientRect();

                // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œç•™å‡ºä¸€äº›è¾¹è·
                const scaleX = (containerRect.width * 0.9) / svgRect.width;
                const scaleY = (containerRect.height * 0.9) / svgRect.height;
                currentZoom = Math.min(scaleX, scaleY);

                applyZoom();
            }
        }

        function applyZoom() {
            if (mapSvg) {
                mapSvg.style.transform = `scale(${currentZoom})`;
                updateZoomDisplay();

                // ç¼©æ”¾æ—¶æ›´æ–°åœ°å›¾ä¿¡æ¯æ˜¾ç¤º
                setTimeout(() => {
                    updateAggregatedInfo();
                    // é‡æ–°ç»˜åˆ¶æŸ±çŠ¶å›¾ä»¥é€‚åº”æ–°çš„ç¼©æ”¾çº§åˆ«
                    redrawExistingCharts();
                }, 100);
            }
        }

        function updateZoomDisplay() {
            const percentage = Math.round(currentZoom * 100);
            document.getElementById('zoom-percentage').textContent = percentage + '%';
        }

        // å¤šé€‰æ§åˆ¶åŠŸèƒ½
        function selectAll() {
            selectedCommunities.clear();
            const communityGroups = document.querySelectorAll('g[data-name*="ç¤¾åŒº"], g[data-name*="æ‘"]');

            communityGroups.forEach(group => {
                const communityName = group.getAttribute('data-name');
                if (communityData[communityName]) {
                    selectedCommunities.add(communityName);
                    updateCommunityVisualState(communityName, true);
                }
            });

            updateAggregatedInfo();
            // é‡æ–°ç»˜åˆ¶æŸ±çŠ¶å›¾ä»¥åæ˜ å…¨é€‰å˜åŒ–
            redrawExistingCharts();
        }

        function clearAll() {
            selectedCommunities.clear();
            const communityGroups = document.querySelectorAll('g[data-name*="ç¤¾åŒº"], g[data-name*="æ‘"]');

            communityGroups.forEach(group => {
                const communityName = group.getAttribute('data-name');
                updateCommunityVisualState(communityName, false);
            });

            // å®Œå…¨æ¸…ç†æ‰€æœ‰ä¿¡æ¯æ¡†å’Œå¼•çº¿
            clearAllInfoOverlays();

            // æ¸…é™¤æ‰€æœ‰æŸ±çŠ¶å›¾
            clearAllCharts();

            // é‡ç½®ä¿¡æ¯æ¡†æ˜¾ç¤ºçŠ¶æ€
            infoBoxesVisible = true;
            const toggleBtn = document.getElementById('toggle-info-btn');
            toggleBtn.textContent = 'éšè—ä¿¡æ¯æ¡†';
            toggleBtn.style.background = '#FF9800';

            updateAggregatedInfo();
        }

        function updateCommunityVisualState(communityName, isSelected) {
            const group = document.querySelector(`g[data-name="${communityName}"]`);
            if (group) {
                const paths = group.querySelectorAll('path');
                paths.forEach(path => {
                    path.classList.toggle('selected', isSelected);
                    if (isSelected) {
                        path.style.fill = '#4CAF50';
                        path.style.stroke = '#2E7D32';
                        path.style.strokeWidth = '2px';
                    } else {
                        path.style.fill = '#e0e0e0';
                        path.style.stroke = '';
                        path.style.strokeWidth = '';
                    }
                });
            }
        }

        // åˆå§‹åŒ–å¼•çº¿è¦†ç›–å±‚
        function initLinesOverlay() {
            if (!linesOverlay) {
                linesOverlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                linesOverlay.id = 'lines-overlay';
                linesOverlay.style.position = 'absolute';
                linesOverlay.style.top = '0';
                linesOverlay.style.left = '0';
                linesOverlay.style.width = '100%';
                linesOverlay.style.height = '100%';
                linesOverlay.style.pointerEvents = 'none';
                linesOverlay.style.zIndex = '999';
                document.getElementById('map-container').appendChild(linesOverlay);
            }
        }

        // åˆå§‹åŒ–æŸ±çŠ¶å›¾è¦†ç›–å±‚
        function initChartsOverlay() {
            if (!chartsOverlay) {
                chartsOverlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                chartsOverlay.id = 'charts-overlay';
                chartsOverlay.style.position = 'absolute';
                chartsOverlay.style.top = '0';
                chartsOverlay.style.left = '0';
                chartsOverlay.style.width = '100%';
                chartsOverlay.style.height = '100%';
                chartsOverlay.style.pointerEvents = 'none';
                chartsOverlay.style.zIndex = '998';
                document.getElementById('map-container').appendChild(chartsOverlay);
            }
        }

        // æ¸…é™¤æ‰€æœ‰å¼•çº¿
        function clearAllLines() {
            if (linesOverlay) {
                // å®Œå…¨æ¸…ç©ºå¼•çº¿è¦†ç›–å±‚
                while (linesOverlay.firstChild) {
                    linesOverlay.removeChild(linesOverlay.firstChild);
                }
            }
        }

        // æ¸…é™¤æ‰€æœ‰æŸ±çŠ¶å›¾
        function clearAllCharts() {
            if (chartsOverlay) {
                while (chartsOverlay.firstChild) {
                    chartsOverlay.removeChild(chartsOverlay.firstChild);
                }
            }
            updateChartStatus();
            // éšè—å›¾ä¾‹
            const legendElement = document.getElementById('chart-legend');
            legendElement.classList.remove('visible');
        }

        // é‡æ–°ç»˜åˆ¶ç°æœ‰å›¾è¡¨ï¼ˆé€‚åº”ç¼©æ”¾æˆ–é€‰æ‹©å˜åŒ–ï¼‰
        function redrawExistingCharts() {
            // å¦‚æœæœ‰é€‰ä¸­çš„æ•°æ®åˆ—ä¸”æœ‰é€‰ä¸­çš„ç¤¾åŒºï¼Œé‡æ–°ç»˜åˆ¶å›¾è¡¨
            if (selectedColumns.size > 0 && selectedCommunities.size > 0) {
                drawChartForSelected();
            }
        }

        // ä¸ºé€‰ä¸­çš„ç¤¾åŒºç»˜åˆ¶å›¾è¡¨
        function drawChartForSelected() {
            if (selectedColumns.size === 0) {
                alert('è¯·å…ˆé€‰æ‹©è¦ç»˜åˆ¶çš„æ•°æ®åˆ—');
                return;
            }

            if (selectedCommunities.size === 0) {
                alert('è¯·å…ˆé€‰æ‹©ç¤¾åŒºåŒºåŸŸ');
                return;
            }

            const chartMode = document.getElementById('chart-mode-select').value;

            // æ¸…é™¤ç°æœ‰å›¾è¡¨
            clearAllCharts();

            // åˆå§‹åŒ–å›¾è¡¨è¦†ç›–å±‚
            initChartsOverlay();

            if (chartMode === 'pie') {
                drawPieCharts();
            } else {
                drawBarCharts();
            }

            updateChartStatus();
            updateLegend(); // æ›´æ–°å›¾ä¾‹
        }

        // æ›´æ–°å›¾ä¾‹æ˜¾ç¤º
        function updateLegend() {
            const legendElement = document.getElementById('chart-legend');
            const legendContent = document.getElementById('legend-content');

            if (selectedColumns.size === 0 || selectedCommunities.size === 0) {
                legendElement.classList.remove('visible');
                return;
            }

            // è·å–é…è‰²æ–¹æ¡ˆ
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
                '#FFEAA7', '#DDA0DD', '#F8BBD0', '#FFB74D'
            ];

            legendContent.innerHTML = '';

            // ä¸ºæ¯ä¸ªé€‰ä¸­çš„æ•°æ®åˆ—åˆ›å»ºå›¾ä¾‹é¡¹
            Array.from(selectedColumns).forEach((columnName, index) => {
                const color = colors[index % colors.length];

                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = color;

                const label = document.createElement('div');
                label.className = 'legend-label';
                label.textContent = columnName;

                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legendContent.appendChild(legendItem);
            });

            legendElement.classList.add('visible');

            // ä¸ºå›¾ä¾‹æ·»åŠ æ‹–æ‹½åŠŸèƒ½
            setupLegendDragging(legendElement);
        }

        // ç»˜åˆ¶å¤šåˆ—æŸ±çŠ¶å›¾
        function drawBarCharts() {
            // ä¸ºæ¯ä¸ªé€‰ä¸­çš„ç¤¾åŒºç»˜åˆ¶å¤šåˆ—æŸ±çŠ¶å›¾
            selectedCommunities.forEach(communityName => {
                const data = communityData[communityName];
                if (data && data.columns) {
                    const group = document.querySelector(`g[data-name="${communityName}"]`);
                    if (group) {
                        // è·å–ç¤¾åŒºçš„ä¸­å¿ƒç‚¹æˆ–ç‚¹å‡»ä½ç½®
                        const existingInfo = infoBoxes.get(communityName);
                        let position;
                        if (existingInfo && existingInfo.clickPosition) {
                            position = existingInfo.clickPosition;
                        } else {
                            position = getElementCenter(group);
                        }

                        drawMultiColumnBarChart(communityName, position, Array.from(selectedColumns), data);
                    }
                }
            });
        }

        // ç»˜åˆ¶é¥¼å›¾
        function drawPieCharts() {
            selectedCommunities.forEach(communityName => {
                const data = communityData[communityName];
                if (data && data.columns) {
                    const group = document.querySelector(`g[data-name="${communityName}"]`);
                    if (group) {
                        const existingInfo = infoBoxes.get(communityName);
                        let position;
                        if (existingInfo && existingInfo.clickPosition) {
                            position = existingInfo.clickPosition;
                        } else {
                            position = getElementCenter(group);
                        }

                        drawPieChart(communityName, position, Array.from(selectedColumns), data);
                    }
                }
            });
        }

        // ç»˜åˆ¶å•ä¸ªç¤¾åŒºçš„é¥¼å›¾
        function drawPieChart(communityName, position, columns, data) {
            const radius = 30 * currentZoom;
            const innerRadius = radius * 0.3; // åˆ›å»ºç¯å½¢å›¾æ•ˆæœ

            // å¤šåˆ—é…è‰²æ–¹æ¡ˆ - é¿å…ä¸åœ°å›¾é€‰ä¸­çš„ç»¿è‰²(#4CAF50)å†²çª
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
                '#FFEAA7', '#DDA0DD', '#F8BBD0', '#FFB74D'
            ];

            // æ”¶é›†æ•°æ®
            const pieData = [];
            let total = 0;

            columns.forEach((columnName, index) => {
                if (data.columns[columnName]) {
                    const value = data.columns[columnName].people_count;
                    if (value > 0) {
                        pieData.push({
                            label: columnName,
                            value: value,
                            color: colors[index % colors.length]
                        });
                        total += value;
                    }
                }
            });

            if (total === 0 || pieData.length === 0) return;

            // åˆ›å»ºé¥¼å›¾ç»„
            const chartGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            chartGroup.setAttribute("data-community", communityName);

            let currentAngle = -90; // ä»é¡¶éƒ¨å¼€å§‹

            // ç»˜åˆ¶é¥¼å›¾æ‰‡å½¢
            pieData.forEach((item, index) => {
                const percentage = item.value / total;
                const angle = percentage * 360;

                if (angle < 1) return; // å¿½ç•¥å¤ªå°çš„æ‰‡å½¢

                const startAngle = (currentAngle * Math.PI) / 180;
                const endAngle = ((currentAngle + angle) * Math.PI) / 180;

                // è®¡ç®—è·¯å¾„åæ ‡
                const x1 = position.x + innerRadius * Math.cos(startAngle);
                const y1 = position.y + innerRadius * Math.sin(startAngle);
                const x2 = position.x + radius * Math.cos(startAngle);
                const y2 = position.y + radius * Math.sin(startAngle);
                const x3 = position.x + radius * Math.cos(endAngle);
                const y3 = position.y + radius * Math.sin(endAngle);
                const x4 = position.x + innerRadius * Math.cos(endAngle);
                const y4 = position.y + innerRadius * Math.sin(endAngle);

                const largeArcFlag = angle > 180 ? 1 : 0;

                // åˆ›å»ºæ‰‡å½¢è·¯å¾„
                const pathData = [
                    `M ${x1} ${y1}`, // ç§»åŠ¨åˆ°å†…åœ†èµ·ç‚¹
                    `L ${x2} ${y2}`, // è¿åˆ°å¤–åœ†èµ·ç‚¹
                    `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x3} ${y3}`, // å¤–åœ†å¼§
                    `L ${x4} ${y4}`, // è¿åˆ°å†…åœ†ç»ˆç‚¹
                    `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${x1} ${y1}`, // å†…åœ†å¼§
                    'Z' // é—­åˆè·¯å¾„
                ].join(' ');

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathData);
                path.setAttribute("fill", item.color);
                path.setAttribute("stroke", "white");
                path.setAttribute("stroke-width", "2");
                path.setAttribute("opacity", "0.8");

                // æ·»åŠ é¼ æ ‡æ‚¬åœæ•ˆæœ
                path.addEventListener('mouseenter', function() {
                    this.setAttribute("opacity", "1");
                    this.setAttribute("stroke-width", "3");
                });
                path.addEventListener('mouseleave', function() {
                    this.setAttribute("opacity", "0.8");
                    this.setAttribute("stroke-width", "2");
                });

                chartGroup.appendChild(path);

                // æ·»åŠ æ ‡ç­¾
                if (percentage > 0.05) { // åªä¸ºå¤§äº5%çš„æ‰‡å½¢æ·»åŠ æ ‡ç­¾
                    const labelAngle = (currentAngle + angle / 2) * Math.PI / 180;
                    const labelRadius = (radius + innerRadius) / 2;
                    const labelX = position.x + labelRadius * Math.cos(labelAngle);
                    const labelY = position.y + labelRadius * Math.sin(labelAngle);

                    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    label.setAttribute("x", labelX);
                    label.setAttribute("y", labelY);
                    label.setAttribute("text-anchor", "middle");
                    label.setAttribute("dominant-baseline", "central");
                    label.setAttribute("font-size", Math.max(8 * currentZoom, 6));
                    label.setAttribute("font-family", "Microsoft YaHei");
                    label.setAttribute("fill", "white");
                    label.setAttribute("font-weight", "bold");
                    label.textContent = item.value;

                    chartGroup.appendChild(label);
                }

                currentAngle += angle;
            });

            // æ·»åŠ ä¸­å¿ƒæ ‡ç­¾ï¼ˆç¤¾åŒºåç§°ï¼‰
            const centerLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            centerLabel.setAttribute("x", position.x);
            centerLabel.setAttribute("y", position.y);
            centerLabel.setAttribute("text-anchor", "middle");
            centerLabel.setAttribute("dominant-baseline", "central");
            centerLabel.setAttribute("font-size", Math.max(10 * currentZoom, 8));
            centerLabel.setAttribute("font-family", "Microsoft YaHei");
            centerLabel.setAttribute("fill", "#333");
            centerLabel.setAttribute("font-weight", "bold");
            centerLabel.textContent = communityName.replace('ç¤¾åŒº', '').replace('æ‘', '');

            chartGroup.appendChild(centerLabel);

            chartsOverlay.appendChild(chartGroup);
        }

        // ç»˜åˆ¶å¤šåˆ—æŸ±çŠ¶å›¾
        function drawMultiColumnBarChart(communityName, position, columns, data) {
            const maxBarHeight = 50; // å‡å°é«˜åº¦ä»¥é€‚åº”å¤šåˆ—æ˜¾ç¤º
            const minBarHeight = 6;
            const barWidth = 8; // å‡å°æŸ±å­å®½åº¦
            const barSpacing = 2; // æŸ±å­é—´è·

            // è®¡ç®—æ‰€æœ‰é€‰ä¸­åˆ—çš„æœ€å¤§å€¼ç”¨äºå½’ä¸€åŒ–
            let maxValue = 0;
            columns.forEach(columnName => {
                if (data.columns[columnName]) {
                    selectedCommunities.forEach(name => {
                        const communityData_item = communityData[name];
                        if (communityData_item && communityData_item.columns && communityData_item.columns[columnName]) {
                            maxValue = Math.max(maxValue, communityData_item.columns[columnName].people_count);
                        }
                    });
                }
            });

            if (maxValue === 0) return;

            // å¤šåˆ—é…è‰²æ–¹æ¡ˆ - é¿å…ä¸åœ°å›¾é€‰ä¸­çš„ç»¿è‰²(#4CAF50)å†²çª
            const colors = [
                { main: '#FF6B6B', light: '#FF8E8E', dark: '#E74C3C' },  // çº¢è‰²ç³»
                { main: '#4ECDC4', light: '#7BDBD2', dark: '#26A69A' },  // é’ç»¿è‰²ç³»
                { main: '#45B7D1', light: '#6BB6FF', dark: '#2196F3' },  // è“è‰²ç³»
                { main: '#96CEB4', light: '#ABEBC6', dark: '#58D68D' },  // è–„è·ç»¿ç³»(è¾ƒæµ…,ä¸é€‰ä¸­ç»¿è‰²åŒºåˆ†)
                { main: '#FFEAA7', light: '#FDCB6E', dark: '#F39C12' },  // é»„è‰²ç³»
                { main: '#DDA0DD', light: '#E6B3E6', dark: '#BA68C8' },  // ç´«è‰²ç³»
                { main: '#F8BBD0', light: '#FCE4EC', dark: '#E91E63' },  // ç²‰è‰²ç³»
                { main: '#FFB74D', light: '#FFCC80', dark: '#FF9800' }   // æ©™è‰²ç³»
            ];

            const totalWidth = columns.length * barWidth + (columns.length - 1) * barSpacing;
            const startX = position.x - totalWidth / 2;

            // ä¸ºæ¯ä¸ªæ•°æ®åˆ—ç»˜åˆ¶æŸ±å­
            columns.forEach((columnName, index) => {
                if (data.columns[columnName]) {
                    const value = data.columns[columnName].people_count;
                    const normalizedHeight = (value / maxValue) * maxBarHeight;
                    const barHeight = Math.max(normalizedHeight * currentZoom, 4);
                    const scaledBarWidth = barWidth * currentZoom;

                    const barX = startX + index * (scaledBarWidth + barSpacing * currentZoom);
                    const colorScheme = colors[index % colors.length];

                    // åˆ›å»ºæŸ±çŠ¶å›¾ç»„
                    const chartGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    chartGroup.setAttribute("data-community", communityName);
                    chartGroup.setAttribute("data-column", columnName);

                    // ç»˜åˆ¶æŸ±å­
                    const bar = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    bar.setAttribute("x", barX);
                    bar.setAttribute("y", position.y - barHeight);
                    bar.setAttribute("width", scaledBarWidth);
                    bar.setAttribute("height", barHeight);
                    bar.setAttribute("fill", colorScheme.main);
                    bar.setAttribute("stroke", colorScheme.dark);
                    bar.setAttribute("stroke-width", "1");
                    bar.setAttribute("rx", "2");

                    // æ•°å€¼æ ‡ç­¾
                    if (value > 0) {
                        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        label.setAttribute("x", barX + scaledBarWidth / 2);
                        label.setAttribute("y", position.y - barHeight - 3);
                        label.setAttribute("text-anchor", "middle");
                        label.setAttribute("font-size", Math.max(8 * currentZoom, 6));
                        label.setAttribute("font-family", "Microsoft YaHei");
                        label.setAttribute("fill", colorScheme.dark);
                        label.setAttribute("font-weight", "bold");
                        label.textContent = value;
                        chartGroup.appendChild(label);
                    }

                    chartGroup.appendChild(bar);
                    chartsOverlay.appendChild(chartGroup);
                }
            });

            // æ·»åŠ ç¤¾åŒºåç§°æ ‡ç­¾
            const nameLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            nameLabel.setAttribute("x", position.x);
            nameLabel.setAttribute("y", position.y + 15);
            nameLabel.setAttribute("text-anchor", "middle");
            nameLabel.setAttribute("font-size", Math.max(9 * currentZoom, 7));
            nameLabel.setAttribute("font-family", "Microsoft YaHei");
            nameLabel.setAttribute("fill", "#333");
            nameLabel.setAttribute("font-weight", "500");
            nameLabel.textContent = communityName.replace('ç¤¾åŒº', '').replace('æ‘', '');

            const nameGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            nameGroup.appendChild(nameLabel);
            chartsOverlay.appendChild(nameGroup);
        }

        // æ¸…é™¤ç‰¹å®šç¤¾åŒºçš„å¼•çº¿
        function clearCommunityLine(communityName) {
            if (linesOverlay) {
                const groups = linesOverlay.querySelectorAll(`g[data-community="${communityName}"]`);
                groups.forEach(group => group.remove());
            }
        }

        // æ›´æ–°æŸ±çŠ¶å›¾æ§åˆ¶çŠ¶æ€
        function updateChartStatus() {
            const drawBtn = document.getElementById('draw-chart-btn');
            const statusElement = document.getElementById('chart-status');

            const hasSelection = selectedCommunities.size > 0;
            const hasColumns = selectedColumns.size > 0;
            const hasCharts = chartsOverlay && chartsOverlay.children.length > 0;

            drawBtn.disabled = !hasSelection || !hasColumns;

            if (hasCharts) {
                const chartMode = document.getElementById('chart-mode-select').value === 'pie' ? 'é¥¼å›¾' : 'æŸ±çŠ¶å›¾';
                const columnNames = Array.from(selectedColumns).join('ã€');
                statusElement.textContent = `å·²ç»˜åˆ¶ ${selectedCommunities.size} ä¸ªç¤¾åŒºçš„ ${columnNames} ${chartMode}`;
            } else if (!hasSelection) {
                statusElement.textContent = 'è¯·å…ˆé€‰æ‹©ç¤¾åŒº';
            } else if (!hasColumns) {
                statusElement.textContent = 'è¯·é€‰æ‹©æ•°æ®åˆ—';
            } else {
                statusElement.textContent = 'å¯ä»¥ç»˜åˆ¶å›¾è¡¨';
            }
        }

        // æ›´æ–°æ•°æ®åˆ—é€‰æ‹©å™¨
        function updateColumnSelector() {
            const checkboxContainer = document.getElementById('column-checkboxes');

            // æ¸…é™¤ç°æœ‰å¤é€‰æ¡†
            checkboxContainer.innerHTML = '';

            // è·å–æ‰€æœ‰å¯ç”¨çš„æ•°æ®åˆ—
            const columns = new Set();
            Object.values(communityData).forEach(data => {
                if (data.columns) {
                    Object.keys(data.columns).forEach(col => {
                        if (col !== 'ç¤¾åŒºåç§°' && col !== 'åç§°') { // æ’é™¤åç§°åˆ—
                            columns.add(col);
                        }
                    });
                }
            });

            availableColumns = Array.from(columns).sort();

            // åˆ›å»ºå¤é€‰æ¡†
            availableColumns.forEach(column => {
                const label = document.createElement('label');
                label.className = 'column-checkbox';
                label.dataset.column = column;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = column;
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedColumns.add(column);
                        label.classList.add('selected');
                    } else {
                        selectedColumns.delete(column);
                        label.classList.remove('selected');
                    }
                    updateChartStatus();
                });

                const span = document.createElement('span');
                span.textContent = column;

                label.appendChild(checkbox);
                label.appendChild(span);
                checkboxContainer.appendChild(label);
            });
        }

        // æ¸…é™¤æ‰€æœ‰åœ°å›¾ä¸Šçš„ä¿¡æ¯æ˜¾ç¤º
        function clearMapInfoOverlays() {
            const container = document.getElementById('map-container');

            // åªæ¸…é™¤ä¸åœ¨é€‰ä¸­åˆ—è¡¨ä¸­çš„ä¿¡æ¯æ¡†
            const existingOverlays = container.querySelectorAll('.map-info-overlay');
            existingOverlays.forEach(overlay => {
                const communityName = overlay.getAttribute('data-community');
                if (!selectedCommunities.has(communityName)) {
                    overlay.remove();
                    infoBoxes.delete(communityName);
                    clearCommunityLine(communityName);
                }
            });
        }

        // å…¨å±€éšè—/æ˜¾ç¤ºæ‰€æœ‰ä¿¡æ¯æ¡†å’Œå¼•çº¿
        function toggleAllInfoBoxes() {
            const toggleBtn = document.getElementById('toggle-info-btn');
            const container = document.getElementById('map-container');

            if (infoBoxesVisible) {
                // éšè—æ‰€æœ‰ä¿¡æ¯æ¡†å’Œå¼•çº¿
                const existingOverlays = container.querySelectorAll('.map-info-overlay');
                existingOverlays.forEach(overlay => {
                    const communityName = overlay.getAttribute('data-community');
                    // ä¿å­˜ä¿¡æ¯æ¡†æ•°æ®åˆ°éšè—åˆ—è¡¨
                    const infoData = infoBoxes.get(communityName);
                    if (infoData) {
                        hiddenInfoBoxes.set(communityName, infoData);
                    }
                    overlay.style.display = 'none';
                });

                // éšè—æ‰€æœ‰å¼•çº¿
                if (linesOverlay) {
                    linesOverlay.style.display = 'none';
                }

                infoBoxesVisible = false;
                toggleBtn.textContent = 'æ˜¾ç¤ºä¿¡æ¯æ¡†';
                toggleBtn.style.background = '#4CAF50';
            } else {
                // æ˜¾ç¤ºæ‰€æœ‰ä¿¡æ¯æ¡†å’Œå¼•çº¿
                const existingOverlays = container.querySelectorAll('.map-info-overlay');
                existingOverlays.forEach(overlay => {
                    overlay.style.display = 'block';
                });

                // æ˜¾ç¤ºæ‰€æœ‰å¼•çº¿
                if (linesOverlay) {
                    linesOverlay.style.display = 'block';
                }

                infoBoxesVisible = true;
                toggleBtn.textContent = 'éšè—ä¿¡æ¯æ¡†';
                toggleBtn.style.background = '#FF9800';
            }
        }

        // éšè—å•ä¸ªä¿¡æ¯æ¡†å’Œå¼•çº¿ï¼ˆåŒå‡»åŠŸèƒ½ï¼‰
        function hideInfoBox(communityName) {
            const container = document.getElementById('map-container');
            const overlay = container.querySelector(`.map-info-overlay[data-community="${communityName}"]`);

            if (overlay) {
                // ä¿å­˜ä¿¡æ¯æ¡†æ•°æ®
                const infoData = infoBoxes.get(communityName);
                if (infoData) {
                    infoData.isHidden = true;
                }

                // éšè—ä¿¡æ¯æ¡†
                overlay.style.display = 'none';

                // éšè—å¯¹åº”çš„å¼•çº¿
                clearCommunityLine(communityName);

                console.log(`å·²éšè— ${communityName} çš„ä¿¡æ¯æ¡†`);
            }
        }

        // æ˜¾ç¤ºå•ä¸ªä¿¡æ¯æ¡†å’Œå¼•çº¿
        function showInfoBox(communityName) {
            const infoData = infoBoxes.get(communityName);
            if (infoData && infoData.isHidden) {
                infoData.isHidden = false;

                // é‡æ–°åˆ›å»ºä¿¡æ¯æ¡†å’Œå¼•çº¿
                const group = document.querySelector(`g[data-name="${communityName}"]`);
                if (group && selectedCommunities.has(communityName)) {
                    const center = infoData.clickPosition || getElementCenter(group);
                    createMapInfoOverlay(communityName, center);
                }
            }
        }

        // å®Œå…¨æ¸…é™¤æ‰€æœ‰ä¿¡æ¯æ¡†å’Œå¼•çº¿
        function clearAllInfoOverlays() {
            const container = document.getElementById('map-container');
            const existingOverlays = container.querySelectorAll('.map-info-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            clearAllLines();
            infoBoxes.clear();
            hiddenInfoBoxes.clear();
        }

        // è·å–SVGå…ƒç´ çš„ä¸­å¿ƒç‚¹
        function getElementCenter(element) {
            try {
                const bbox = element.getBBox();
                const svgRect = mapSvg.getBoundingClientRect();
                const containerRect = document.getElementById('map-container').getBoundingClientRect();

                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                const scaleX = svgRect.width / mapSvg.viewBox.baseVal.width;
                const scaleY = svgRect.height / mapSvg.viewBox.baseVal.height;

                // è®¡ç®—ä¸­å¿ƒç‚¹åœ¨å®¹å™¨ä¸­çš„ä½ç½®
                const centerX = (bbox.x + bbox.width / 2) * scaleX * currentZoom + (containerRect.width - svgRect.width) / 2;
                const centerY = (bbox.y + bbox.height / 2) * scaleY * currentZoom + (containerRect.height - svgRect.height) / 2;

                return { x: centerX, y: centerY };
            } catch (e) {
                console.error('Error getting element center:', e);
                return { x: 100, y: 100 };
            }
        }

        // æ£€æŸ¥ä¸¤ä¸ªçŸ©å½¢æ˜¯å¦é‡å 
        function isOverlapping(rect1, rect2) {
            return !(rect1.right < rect2.left ||
                    rect2.right < rect1.left ||
                    rect1.bottom < rect2.top ||
                    rect2.bottom < rect1.top);
        }

        // æ‰¾åˆ°ä¸é‡å çš„ä½ç½®
        function findNonOverlappingPosition(preferredX, preferredY, width, height, containerRect, excludeCommunity = null) {
            const margin = 10;
            const testRect = {
                left: preferredX,
                top: preferredY,
                right: preferredX + width,
                bottom: preferredY + height
            };

            // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰ä¿¡æ¯æ¡†é‡å ï¼Œä½†æ’é™¤æŒ‡å®šçš„ç¤¾åŒºï¼ˆé€šå¸¸æ˜¯è‡ªèº«ï¼‰
            let hasOverlap = false;
            for (let [key, info] of infoBoxes) {
                if (key === excludeCommunity) continue;  // è·³è¿‡æŒ‡å®šçš„ç¤¾åŒº
                if (isOverlapping(testRect, info.rect)) {
                    hasOverlap = true;
                    break;
                }
            }

            if (!hasOverlap) {
                return { x: preferredX, y: preferredY };
            }

            // å¦‚æœé‡å ï¼Œå°è¯•åœ¨å³ä¾§æ‰¾ä½ç½®
            const positions = [
                // å³ä¾§åŒºåŸŸ
                { x: containerRect.width - width - margin, y: preferredY },
                { x: containerRect.width - width - margin, y: preferredY + 100 },
                { x: containerRect.width - width - margin, y: preferredY - 100 },
                // å·¦ä¾§åŒºåŸŸ
                { x: margin, y: preferredY },
                { x: margin, y: preferredY + 100 },
                { x: margin, y: preferredY - 100 },
                // ä¸‹æ–¹åŒºåŸŸ
                { x: preferredX, y: containerRect.height - height - margin },
                { x: preferredX + 100, y: containerRect.height - height - margin },
                { x: preferredX - 100, y: containerRect.height - height - margin },
            ];

            for (let pos of positions) {
                if (pos.x < margin || pos.y < margin ||
                    pos.x + width > containerRect.width - margin ||
                    pos.y + height > containerRect.height - margin) {
                    continue;
                }

                const testPos = {
                    left: pos.x,
                    top: pos.y,
                    right: pos.x + width,
                    bottom: pos.y + height
                };

                let overlap = false;
                for (let [key, info] of infoBoxes) {
                    if (key === excludeCommunity) continue;  // è·³è¿‡æŒ‡å®šçš„ç¤¾åŒº
                    if (isOverlapping(testPos, info.rect)) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    return pos;
                }
            }

            // å¦‚æœéƒ½é‡å ï¼Œè¿”å›ä¸€ä¸ªå †å ä½ç½®
            return {
                x: containerRect.width - width - margin - (infoBoxes.size * 20),
                y: margin + (infoBoxes.size * 20)
            };
        }

        // åˆ›å»ºåœ°å›¾ä¸Šçš„ä¿¡æ¯æ˜¾ç¤º
        function createMapInfoOverlay(communityName, center) {
            const data = communityData[communityName];
            if (!data || !data.columns) return null;

            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ä¿¡æ¯æ¡†
            const container = document.getElementById('map-container');
            const existingOverlay = container.querySelector(`.map-info-overlay[data-community="${communityName}"]`);
            if (existingOverlay) {
                // å¦‚æœå·²ç»å­˜åœ¨ï¼Œç›´æ¥è¿”å›
                return existingOverlay;
            }

            const containerRect = container.getBoundingClientRect();
            const overlay = document.createElement('div');
            overlay.className = 'map-info-overlay';
            overlay.setAttribute('data-community', communityName);

            let totalPeople = 0;
            let infoHTML = `<div class="map-info-title">${data.name}</div>`;

            // æ˜¾ç¤ºæœ‰æ•°æ®çš„é¡¹ç›®
            for (const [colName, colData] of Object.entries(data.columns)) {
                if (colData.people_count > 0) {
                    infoHTML += `
                        <div class="map-info-item">
                            <span class="map-info-label">${colName}:</span>
                            <span class="map-info-value">${colData.people_count}äºº</span>
                        </div>
                    `;
                    totalPeople += colData.people_count;
                }
            }

            if (totalPeople > 0) {
                infoHTML += `<div class="map-info-total">æ€»è®¡: ${totalPeople}äºº</div>`;
            }

            overlay.innerHTML = infoHTML;

            // è®¡ç®—å°ºå¯¸
            const overlayWidth = 160;
            const overlayHeight = 90;

            // ä¼˜å…ˆæ”¾åœ¨å³ä¾§
            let preferredX = containerRect.width - overlayWidth - 20;
            let preferredY = center.y - overlayHeight / 2;

            // å¦‚æœä¸­å¿ƒç‚¹åœ¨å³ä¾§ï¼Œåˆ™æ”¾å·¦ä¾§
            if (center.x > containerRect.width * 0.7) {
                preferredX = 20;
            }

            // ç¡®ä¿åœ¨å®¹å™¨è¾¹ç•Œå†…
            preferredY = Math.max(10, Math.min(preferredY, containerRect.height - overlayHeight - 10));

            // æ‰¾åˆ°ä¸é‡å çš„ä½ç½®
            const position = findNonOverlappingPosition(preferredX, preferredY, overlayWidth, overlayHeight, containerRect, communityName);

            overlay.style.left = position.x + 'px';
            overlay.style.top = position.y + 'px';

            // å­˜å‚¨ä½ç½®ä¿¡æ¯
            const existingInfo = infoBoxes.get(communityName);
            infoBoxes.set(communityName, {
                element: overlay,
                rect: {
                    left: position.x,
                    top: position.y,
                    right: position.x + overlayWidth,
                    bottom: position.y + overlayHeight
                },
                center: center,
                clickPosition: existingInfo ? existingInfo.clickPosition : center,  // ä¿ç•™ç‚¹å‡»ä½ç½®
                isManuallyMoved: false  // æ·»åŠ æ‰‹åŠ¨ç§»åŠ¨æ ‡è®°
            });

            // æ·»åŠ æ‹–æ‹½äº‹ä»¶å’ŒåŒå‡»éšè—äº‹ä»¶
            makeDraggable(overlay, communityName);

            // æ·»åŠ åŒå‡»éšè—åŠŸèƒ½
            overlay.addEventListener('dblclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
                hideInfoBox(communityName);
            });

            container.appendChild(overlay);

            // åˆ›å»ºå¼•çº¿ - ä½¿ç”¨ç‚¹å‡»ä½ç½®ä½œä¸ºèµ·ç‚¹
            const lineStartPoint = existingInfo && existingInfo.clickPosition ? existingInfo.clickPosition : center;
            createLeaderLine(lineStartPoint, { x: position.x + overlayWidth / 2, y: position.y + overlayHeight / 2 }, communityName);

            return overlay;
        }

        // åˆ›å»ºå¼•çº¿
        function createLeaderLine(fromCenter, toCenter, communityName) {
            if (!linesOverlay) {
                initLinesOverlay();
            }

            // å…ˆæ¸…é™¤è¯¥ç¤¾åŒºçš„ç°æœ‰å¼•çº¿
            clearCommunityLine(communityName);

            // ç®€åŒ–åæ ‡è®¡ç®— - ç›´æ¥ä½¿ç”¨å®¹å™¨åæ ‡
            const fromX = fromCenter.x;
            const fromY = fromCenter.y;
            const toX = toCenter.x;
            const toY = toCenter.y;

            // åˆ›å»ºå¼•çº¿ç»„ï¼Œæ–¹ä¾¿ç®¡ç†
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            group.setAttribute("data-community", communityName);

            // åˆ›å»ºå¼•çº¿
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", fromX);
            line.setAttribute("y1", fromY);
            line.setAttribute("x2", toX);
            line.setAttribute("y2", toY);
            line.setAttribute("stroke", "#2196F3");
            line.setAttribute("stroke-width", "2");
            line.setAttribute("stroke-dasharray", "5,3");
            line.setAttribute("opacity", "0.8");

            // åˆ›å»ºèµ·ç‚¹åœ†ç‚¹
            const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            dot.setAttribute("cx", fromX);
            dot.setAttribute("cy", fromY);
            dot.setAttribute("r", "4");
            dot.setAttribute("fill", "#2196F3");
            dot.setAttribute("stroke", "white");
            dot.setAttribute("stroke-width", "1.5");

            group.appendChild(line);
            group.appendChild(dot);
            linesOverlay.appendChild(group);
        }

        // ä½¿å…ƒç´ å¯æ‹–æ‹½
        function makeDraggable(element, communityName) {
            element.addEventListener('mousedown', function(e) {
                e.preventDefault();
                dragState.isDragging = true;
                dragState.element = element;
                dragState.communityName = communityName;
                dragState.offsetX = e.clientX - element.offsetLeft;
                dragState.offsetY = e.clientY - element.offsetTop;

                element.classList.add('dragging');
                document.body.style.cursor = 'grabbing';
            });
        }

        // è®¾ç½®å›¾ä¾‹æ‹–æ‹½åŠŸèƒ½
        function setupLegendDragging(legendElement) {
            legendElement.addEventListener('mousedown', function(e) {
                e.preventDefault();
                dragState.isDragging = true;
                dragState.element = legendElement;
                dragState.isLegend = true;
                dragState.offsetX = e.clientX - legendElement.offsetLeft;
                dragState.offsetY = e.clientY - legendElement.offsetTop;

                legendElement.classList.add('dragging');
                document.body.style.cursor = 'grabbing';
            });
        }

        // æ·»åŠ å…¨å±€é¼ æ ‡äº‹ä»¶
        document.addEventListener('mousemove', function(e) {
            if (dragState.isDragging && dragState.element) {
                let newX = e.clientX - dragState.offsetX;
                let newY = e.clientY - dragState.offsetY;

                if (dragState.isLegend) {
                    // å›¾ä¾‹æ‹–æ‹½ - é™åˆ¶åœ¨çª—å£èŒƒå›´å†…
                    const elementRect = dragState.element.getBoundingClientRect();
                    newX = Math.max(5, Math.min(newX, window.innerWidth - elementRect.width - 5));
                    newY = Math.max(5, Math.min(newY, window.innerHeight - elementRect.height - 5));
                } else {
                    // ä¿¡æ¯æ¡†æ‹–æ‹½ - é™åˆ¶åœ¨åœ°å›¾å®¹å™¨å†…
                    const container = document.getElementById('map-container');
                    const containerRect = container.getBoundingClientRect();
                    const elementRect = dragState.element.getBoundingClientRect();
                    newX = Math.max(5, Math.min(newX, containerRect.width - elementRect.width - 5));
                    newY = Math.max(5, Math.min(newY, containerRect.height - elementRect.height - 5));
                }

                dragState.element.style.left = newX + 'px';
                dragState.element.style.top = newY + 'px';

                // æ›´æ–°å­˜å‚¨çš„ä½ç½®ä¿¡æ¯ï¼ˆä»…å¯¹ä¿¡æ¯æ¡†ï¼‰
                if (!dragState.isLegend) {
                    const info = infoBoxes.get(dragState.communityName);
                    if (info) {
                        const elementRect = dragState.element.getBoundingClientRect();
                        info.rect.left = newX;
                        info.rect.top = newY;
                        info.rect.right = newX + elementRect.width;
                        info.rect.bottom = newY + elementRect.height;

                        // æ›´æ–°å¼•çº¿ - ä½¿ç”¨å­˜å‚¨çš„ç‚¹å‡»ä½ç½®ä½œä¸ºèµ·ç‚¹
                        const newCenter = {
                            x: newX + elementRect.width / 2,
                            y: newY + elementRect.height / 2
                        };
                        const lineStartPoint = info.clickPosition || info.center;
                        createLeaderLine(lineStartPoint, newCenter, dragState.communityName);
                    }
                }
            }
        });

        document.addEventListener('mouseup', function(e) {
            if (dragState.isDragging) {
                dragState.element.classList.remove('dragging');

                // æ ‡è®°è¯¥ä¿¡æ¯æ¡†ä¸ºæ‰‹åŠ¨ç§»åŠ¨è¿‡çš„ï¼ˆä»…å¯¹ä¿¡æ¯æ¡†ï¼‰
                if (!dragState.isLegend) {
                    const info = infoBoxes.get(dragState.communityName);
                    if (info) {
                        info.isManuallyMoved = true;
                    }
                }

                // é‡ç½®æ‹–æ‹½çŠ¶æ€
                dragState.isDragging = false;
                dragState.element = null;
                dragState.communityName = null;
                dragState.isLegend = false;
                document.body.style.cursor = 'default';
            }
        });

        // åŠ è½½SVGåœ°å›¾
        function loadSVGMap() {
            fetch('/static/åœ°å›¾çº¿ç¨¿.svg')
                .then(response => response.text())
                .then(svgText => {
                    const mapContainer = document.getElementById('map-container');
                    mapContainer.innerHTML = svgText;

                    // è·å–SVGå…ƒç´ å¼•ç”¨
                    mapSvg = mapContainer.querySelector('svg');
                    if (mapSvg) {
                        mapSvg.id = 'map-svg';

                        // åˆå§‹åŒ–æ—¶è‡ªåŠ¨é€‚åº”çª—å£
                        setTimeout(() => {
                            fitToView();
                        }, 100);
                    }

                    // ä¸ºæ¯ä¸ªç¤¾åŒºåŒºåŸŸæ·»åŠ ç‚¹å‡»äº‹ä»¶
                    const communityGroups = document.querySelectorAll('g[data-name*="ç¤¾åŒº"], g[data-name*="æ‘"]');
                    communityGroups.forEach(group => {
                        const communityName = group.getAttribute('data-name');

                        // ä¸ºæ‰€æœ‰è·¯å¾„æ·»åŠ æ ·å¼ç±»
                        const paths = group.querySelectorAll('path');
                        paths.forEach(path => {
                            path.classList.add('community-area');
                            path.style.fill = '#e0e0e0';
                            path.style.cursor = 'pointer';
                        });

                        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                        group.addEventListener('click', function(e) {
                            // è®¡ç®—ç‚¹å‡»ä½ç½®ç›¸å¯¹äºå®¹å™¨çš„åæ ‡
                            const containerRect = document.getElementById('map-container').getBoundingClientRect();
                            const svgRect = mapSvg.getBoundingClientRect();

                            // è®¡ç®—ç›¸å¯¹äºå®¹å™¨çš„ç‚¹å‡»ä½ç½®
                            const clickX = e.clientX - containerRect.left;
                            const clickY = e.clientY - containerRect.top;

                            toggleCommunitySelection(communityName, { x: clickX, y: clickY });
                        });

                        // æ·»åŠ æ‚¬åœæç¤º
                        group.setAttribute('title', communityName);
                    });

                    // æ·»åŠ çª—å£å¤§å°æ”¹å˜æ—¶çš„å“åº”
                    window.addEventListener('resize', function() {
                        setTimeout(fitToView, 100);
                    });
                })
                .catch(error => {
                    console.error('åŠ è½½SVGåœ°å›¾å¤±è´¥:', error);
                    document.getElementById('map-container').innerHTML =
                        '<div class="error">åœ°å›¾åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨</div>';
                });
        }

        // åŠ è½½æ‰€æœ‰ç¤¾åŒºæ•°æ®
        function loadCommunityData() {
            fetch('/api/communities')
                .then(response => response.json())
                .then(data => {
                    communityData = data;
                    console.log('ç¤¾åŒºæ•°æ®åŠ è½½å®Œæˆ:', data);

                    // æ›´æ–°æ•°æ®åˆ—é€‰æ‹©å™¨
                    updateColumnSelector();
                    updateChartStatus();
                })
                .catch(error => {
                    console.error('åŠ è½½ç¤¾åŒºæ•°æ®å¤±è´¥:', error);
                });
        }

        // åˆ‡æ¢ç¤¾åŒºé€‰æ‹©çŠ¶æ€
        function toggleCommunitySelection(communityName, clickPosition = null) {
            if (selectedCommunities.has(communityName)) {
                selectedCommunities.delete(communityName);
                updateCommunityVisualState(communityName, false);
            } else {
                selectedCommunities.add(communityName);
                updateCommunityVisualState(communityName, true);

                // å¦‚æœæä¾›äº†ç‚¹å‡»ä½ç½®ï¼Œå­˜å‚¨å®ƒ
                if (clickPosition) {
                    const existingInfo = infoBoxes.get(communityName);
                    if (existingInfo) {
                        existingInfo.clickPosition = clickPosition;
                    } else {
                        // å¦‚æœä¿¡æ¯æ¡†è¿˜ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªä¸´æ—¶å­˜å‚¨
                        infoBoxes.set(communityName, { clickPosition: clickPosition });
                    }
                }
            }

            updateAggregatedInfo();
            updateChartStatus(); // æ›´æ–°æŸ±çŠ¶å›¾çŠ¶æ€

            // é‡æ–°ç»˜åˆ¶æŸ±çŠ¶å›¾ä»¥åæ˜ é€‰æ‹©å˜åŒ–
            redrawExistingCharts();
        }

        // æ›´æ–°èšåˆä¿¡æ¯æ˜¾ç¤º
        function updateAggregatedInfo() {
            const infoDiv = document.getElementById('community-info');
            const selectedCountSpan = document.getElementById('selected-count');

            selectedCountSpan.textContent = selectedCommunities.size;

            // æ¸…é™¤åœ°å›¾ä¸Šçš„ä¿¡æ¯æ˜¾ç¤º
            clearMapInfoOverlays();

            if (selectedCommunities.size === 0) {
                infoDiv.innerHTML = '<div class="no-data">è¯·ç‚¹å‡»åœ°å›¾ä¸Šçš„ç¤¾åŒº/æ‘æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ï¼Œæ”¯æŒå¤šé€‰</div>';
                return;
            }

            // æ˜¾ç¤ºåœ°å›¾ä¸Šçš„ä¿¡æ¯
            selectedCommunities.forEach(communityName => {
                const group = document.querySelector(`g[data-name="${communityName}"]`);
                if (group && communityData[communityName]) {
                    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ä¸”è¢«æ‰‹åŠ¨ç§»åŠ¨è¿‡
                    const existingInfo = infoBoxes.get(communityName);

                    // å¦‚æœä¿¡æ¯æ¡†è¢«å•ç‹¬éšè—æˆ–è€…å…¨å±€éšè—ï¼Œè·³è¿‡åˆ›å»º
                    if ((existingInfo && existingInfo.isHidden) || !infoBoxesVisible) {
                        return;
                    }

                    if (existingInfo && existingInfo.isManuallyMoved && existingInfo.element && existingInfo.element.parentNode) {
                        // å¦‚æœä¿¡æ¯æ¡†è¢«æ‰‹åŠ¨ç§»åŠ¨è¿‡ä¸”è¿˜åœ¨DOMä¸­ï¼Œè·³è¿‡åˆ›å»º
                        return;
                    }

                    // ä½¿ç”¨ç‚¹å‡»ä½ç½®ä½œä¸ºå¼•çº¿èµ·ç‚¹ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨åŒºåŸŸä¸­å¿ƒ
                    let center;
                    if (existingInfo && existingInfo.clickPosition) {
                        center = existingInfo.clickPosition;
                    } else {
                        center = getElementCenter(group);
                    }

                    createMapInfoOverlay(communityName, center);
                }
            });

            if (selectedCommunities.size === 1) {
                // å•é€‰æ—¶æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                const communityName = Array.from(selectedCommunities)[0];
                showSingleCommunityInfo(communityName);
                return;
            }

            // å¤šé€‰æ—¶æ˜¾ç¤ºèšåˆä¿¡æ¯
            showAggregatedInfo();
        }

        // æ˜¾ç¤ºå•ä¸ªç¤¾åŒºä¿¡æ¯
        function showSingleCommunityInfo(communityName) {
            const infoDiv = document.getElementById('community-info');

            if (communityData[communityName]) {
                const data = communityData[communityName];

                let infoHTML = `
                    <div class="info-item">
                        <span class="info-label">åç§°:</span>
                        <span class="info-value">${data.name}</span>
                    </div>
                `;

                // ä½¿ç”¨åŠ¨æ€åˆ—åæ˜¾ç¤ºæ•°æ®
                if (data.columns) {
                    for (const [colName, colData] of Object.entries(data.columns)) {
                        if (colData.raw_data !== '0' && colData.raw_data !== 'nan') {
                            infoHTML += `
                                <div class="info-item">
                                    <span class="info-label">${colName}:</span>
                                    <span class="info-value">${colData.raw_data} (äººæ•°: ${colData.people_count})</span>
                                </div>
                            `;
                        }
                    }

                    // è®¡ç®—æ€»äººæ•°
                    const totalPeople = Object.values(data.columns).reduce((sum, col) => sum + col.people_count, 0);

                    infoHTML += `
                        <div class="info-item" style="border-top: 2px solid #ddd; margin-top: 10px; padding-top: 10px;">
                            <span class="info-label">æ€»äººæ•°:</span>
                            <span class="info-value" style="font-weight: bold; color: #2196F3;">${totalPeople}äºº</span>
                        </div>
                    `;
                }

                infoDiv.innerHTML = infoHTML;
            }
        }

        // æ˜¾ç¤ºèšåˆä¿¡æ¯
        function showAggregatedInfo() {
            const infoDiv = document.getElementById('community-info');
            const selectedNames = Array.from(selectedCommunities);

            // è®¡ç®—èšåˆæ•°æ®
            const aggregatedData = {};
            let totalPeople = 0;

            // è·å–æ‰€æœ‰å¯èƒ½çš„åˆ—å
            const allColumns = new Set();
            selectedNames.forEach(name => {
                const data = communityData[name];
                if (data && data.columns) {
                    Object.keys(data.columns).forEach(col => allColumns.add(col));
                }
            });

            // èšåˆæ¯ä¸ªåˆ—çš„æ•°æ®
            allColumns.forEach(colName => {
                aggregatedData[colName] = {
                    total_people: 0,
                    communities: []
                };

                selectedNames.forEach(name => {
                    const data = communityData[name];
                    if (data && data.columns && data.columns[colName]) {
                        const colData = data.columns[colName];
                        aggregatedData[colName].total_people += colData.people_count;
                        if (colData.people_count > 0) {
                            aggregatedData[colName].communities.push({
                                name: name,
                                count: colData.people_count,
                                raw: colData.raw_data
                            });
                        }
                    }
                });

                totalPeople += aggregatedData[colName].total_people;
            });

            // ç”Ÿæˆæ˜¾ç¤ºHTML
            let infoHTML = `
                <div class="info-item" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <span class="info-label">èšåˆç»Ÿè®¡ (${selectedNames.length}ä¸ªåœ°åŒº):</span>
                    <span class="info-value">${selectedNames.join('ã€')}</span>
                </div>
            `;

            // æ˜¾ç¤ºå„ç±»åˆ«çš„èšåˆç»Ÿè®¡
            for (const [colName, colData] of Object.entries(aggregatedData)) {
                if (colData.total_people > 0) {
                    infoHTML += `
                        <div class="info-item">
                            <span class="info-label">${colName}:</span>
                            <span class="info-value" style="font-weight: bold;">${colData.total_people}äºº</span>
                            <div style="margin-top: 5px; font-size: 12px; color: #666;">
                                ${colData.communities.map(c => `${c.name}: ${c.count}äºº`).join(' | ')}
                            </div>
                        </div>
                    `;
                }
            }

            infoHTML += `
                <div class="info-item" style="border-top: 2px solid #ddd; margin-top: 10px; padding-top: 10px; background: #f3e5f5;">
                    <span class="info-label">æ€»è®¡äººæ•°:</span>
                    <span class="info-value" style="font-weight: bold; color: #9C27B0; font-size: 18px;">${totalPeople}äºº</span>
                </div>
            `;

            infoDiv.innerHTML = infoHTML;
        }


    </script>
</body>
</html>